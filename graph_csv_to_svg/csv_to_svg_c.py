# -*- coding: utf-8 -*-
"""csv_to_svg_c.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LIWSL2AFA8eIry5G9Q_FwPDoXqZggv3O
"""

# Parse the CSV data
csv_data = r"""source,target,label,style
éq. déc.,déc.,3.1.23
éq. irr.,irr.,3.1.24
éq. comp. réd.,comp. réd.,3.1.25
unit.,irr.,3.2.3,dashed
éq. unit.,éq. irr.,éq. 3.2.3,dashed
unit.,déc.,3.2.3,dashed
éq. unit.,éq. déc.,éq. 3.2.3,dashed
fini,éq. unit.,3.2.4
fini,irr.,3.2.5,dashed
fini,déc.,3.2.5,dashed
irr.,indéc.,3.2.7 pas la réciproque
fini,comp. réd.,3.2.8 Maschke
$\phi \nsim \rho$,$\frac{\gamma}{x^2}$,test
"""

csv_node=r"""name,texlbl
fini,$\mathrm{card}(G)<\infty$
"""

"""!sudo apt update
!sudo apt install graphviz libgraphviz-dev
#ne pas oublier la version dev de graphviz

!pip install pygraphviz
"""

import pandas as pd
import io
import unicodedata
import re
import networkx as nx
import pygraphviz # Import the Graph class
from networkx.drawing.nx_pydot import to_pydot
from IPython.display import SVG
import subprocess

# Function to convert text to a valid Python variable name
def to_variable_name(text):
    # Normalize the text to decompose accented characters
    text = unicodedata.normalize('NFKD', str(text))

    # Remove non-ASCII characters and replace with their base letters
    text = text.encode('ascii', 'ignore').decode('ascii')

    # Remove remaining special characters and replace spaces with underscores
    text = re.sub(r'[^\w\s]', '', text)
    text = text.replace(' ', '_')

    return text

def csv_to_pd(csv_data,csv_node=""):
    # Create DataFrame A
    A = pd.read_csv(io.StringIO(csv_data))
    D = ""
       # Create DataFrame B with distinct elements from first two columns
    B_data = pd.concat([A['source'], A['target']]).drop_duplicates()
    B = pd.DataFrame({
        'texlbl': B_data,
        'name': B_data.apply(to_variable_name)
    })

    #If a node CSV is provided, update texlbl in B with node labels
    if csv_node:
        D = pd.read_csv(io.StringIO(csv_node))
        #print(D)
        #print(B)
        # Merge B with D to update texlbl
        B = B.merge(D[['name', 'texlbl']], on='name', how='left')
        #print(B)
        # Update texlbl column, keeping original if no match in D
        B['texlbl'] = B['texlbl_y'].fillna(B['texlbl_x'])

        # Drop the temporary merge columns
        B = B.drop(columns=['texlbl_x', 'texlbl_y'])
        #print(B)

    # Create DataFrame C

    # Create DataFrame C
    C = pd.DataFrame({
        'source_name': A['source'].apply(to_variable_name),
        'target_name': A['target'].apply(to_variable_name),
        'label': A['label'],
        'style': A.iloc[:, 3]
    })

    C.fillna("solid", inplace=True)
    return (B,C)
(B,C)=csv_to_pd(csv_data,csv_node)

print("\nDataFrame B:")
print(B)
print("\nDataFrame C:")
print(C)

def pd_to_nx(B,C):
    # Assuming B and C DataFrames are already created from the previous code

    # Create an empty graph
    G = nx.DiGraph()  # Using DiGraph for a directed graph

    # Add nodes from table B
    # Use the 'name' column as node identifier and 'texlbl' as a node attribute
    for _, row in B.iterrows():
        G.add_node(
            row['name'],  # Use the converted variable name as node identifier
            texlbl=row['texlbl']  # Original label as a node attribute
        )

    # Add edges from table C
    for _, row in C.iterrows():
        # Add an edge using the converted source and target names
        G.add_edge(
            row['source_name'],  # Source node
            row['target_name'],  # Target node
            style=row.get('style', ''),  # Style attribute
            texlbl=row.get('label', '')  # Label attribute
        )
    return G
G = pd_to_nx(B,C)
# Optional: Verify the graph
print("Number of nodes:", G.number_of_nodes())
print("Number of edges:", G.number_of_edges())

# Optional: Print node and edge details
print("\nNodes:")
for node in G.nodes(data=True):
    print(node)

print("\nEdges:")
for edge in G.edges(data=True):
    print(edge)

# Convertir le graphe en pygraphviz AGraph
#A = to_agraph(G)

# Personnaliser le style
#A.graph_attr.update(rankdir="LR")  # Orientation de gauche à droite
#A.node_attr.update(fontsize="10", style="filled")
#A.edge_attr.update(color="black", arrowsize="0.5")
#A.graph_attr.update(encoding="utf-8")

# Écrire directement dans un fichier DOT
#A.write("graph.dot")

def nx_to_dot(G,tex_file_path="graph"):
    dot_graph = to_pydot(G)

    # Save the DOT file
    with open(tex_file_path+".dot", "w", encoding="utf-8") as f:
        f.write(dot_graph.to_string())
    return(dot_graph)
dot_graph=nx_to_dot(G)
print(dot_graph.to_string())



# Écrire directement dans un fichier DOT
#A.write("graph.dot")



# Method 3: Using read().splitlines()
with open('graph.dot', 'r') as file:
    lines = file.read().splitlines()
    for line in lines:
        print(line)
# Method 3: Using read().splitlines()
with open('graph.dot', 'r') as file:
    lines = file.read().splitlines()
    for line in lines:
        print(line)

"""!pip install dot2tex

!sudo apt install pdf2svg

!sudo apt update
!sudo apt install texlive-xetex

!dot2tex  --docpreamble "\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc} \usepackage{amssymb}" -tmath --autosize graph.dot > graph.tex
#!latex
"""

def insert_resizebox(tex_file_path):
    """Inserts \resizebox{\linewidth}{!}{ and } into a LaTeX file.

    Args:
        tex_file_path: Path to the LaTeX file.

    Returns:
        None
    """

    with open(tex_file_path, 'r') as f:
        lines = f.readlines()

    # Find the line containing \pagestyle{empty}
    for i, line in enumerate(lines):
        if r"\pagestyle{empty}" in line:
            lines.insert(i + 1, r"\resizebox{\linewidth}{!}{")
            break

    # Find the line containing \end{document}
    for i,line in enumerate(lines):
        if r"\end{document}" in line:
            lines.insert(i-1, r"}")
            break

    with open(tex_file_path, 'w') as f:
        f.writelines(lines)

# Example usage:
tex_file_path = "graph.tex"
insert_resizebox(tex_file_path)

"""# Parse the CSV data
csv_data = r'''source,target,label,style
twts,$t^2$,$w_4$
éq. déc.,déc.,3.1.23
éq. irr.,irr.,3.1.24
éq. comp. réd.,comp. réd.,3.1.25
unit.,irr.,3.2.3,dashed
éq. unit.,éq. irr.,éq. 3.2.3,dashed
unit.,déc.,3.2.3,dashed
éq. unit.,éq. déc.,éq. 3.2.3,dashed
fini,éq. unit.,3.2.4
fini,irr.,3.2.5,dashed
fini,déc.,3.2.5,dashed
irr.,indéc.,3.2.7 pas la réciproque
fini,comp. réd.,3.2.8 Maschke
$\phi \nsim \rho$,$\frac{\gamma}{x^2}$,test
'''
"""

tex_file_path = "graph2"
(B,C)=csv_to_pd(csv_data)
G = pd_to_nx(B,C)
nx_to_dot(G,tex_file_path)


# Using subprocess for shell commands
subprocess.run(f'dot2tex --docpreamble "\\usepackage[utf8]{{inputenc}} \\usepackage[T1]{{fontenc}} \\usepackage{{amssymb}}" -tmath --autosize "{tex_file_path}.dot" > "{tex_file_path}.tex"', shell=True)
insert_resizebox(f"{tex_file_path}.tex")
subprocess.run(f'xelatex "{tex_file_path}.tex"', shell=True)

subprocess.run(f'pdf2svg "{tex_file_path}.pdf" "{tex_file_path}.svg"', shell=True)

SVG(f"{tex_file_path}.svg")



#
#!dot2tex  --docpreamble "\usepackage[utf8]{inputenc} \usepackage[T1]{fontenc} \usepackage{amssymb}" -tmath --autosize testnode.dot > testnode.tex
#!latex

#!xelatex testnode.tex
#!pdf2svg testnode.pdf testnode.svg

#SVG("testnode.svg")

"""csv_node=r'''name,texlbl
fini,$\text{card}(G)<\infty$
'''
"""

def csv_to_svg(csv_data,csv_node="",tex_file_path = "graph"):
    (B,C)=csv_to_pd(csv_data,csv_node)
    G = pd_to_nx(B,C)
    nx_to_dot(G,tex_file_path)


    # Using subprocess for shell commands
    subprocess.run(f'dot2tex --docpreamble "\\usepackage[utf8]{{inputenc}} \\usepackage[T1]{{fontenc}} \\usepackage{{amssymb}}" -tmath --autosize "{tex_file_path}.dot" > "{tex_file_path}.tex"', shell=True)
    insert_resizebox(f"{tex_file_path}.tex")
    subprocess.run(f'xelatex "{tex_file_path}.tex"', shell=True)

    subprocess.run(f'pdf2svg "{tex_file_path}.pdf" "{tex_file_path}.svg"', shell=True)

    display(SVG(f"{tex_file_path}.svg"))

#csv_to_svg(csv_data)
csv_to_svg(csv_data,csv_node,"testnode")